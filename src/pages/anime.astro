---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import { sidebarLayoutConfig, siteConfig } from "../config";
import localAnimeList from "../data/anime";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";
import MainGridLayout from "../layouts/MainGridLayout.astro";

// æ£€æŸ¥ç•ªå‰§é¡µé¢æ˜¯å¦å¯ç”¨
if (!siteConfig.featurePages.anime) {
	return Astro.redirect("/404/");
}

// æ£€æŸ¥æ˜¯å¦ä¸ºåŒä¾§è¾¹æ æ¨¡å¼
const isBothSidebarMode = sidebarLayoutConfig.position === "both";

// Bangumi APIé…ç½®
const BANGUMI_USER_ID = siteConfig.bangumi?.userId || "your-user-id"; // ç”¨æˆ·ID
const BANGUMI_API_BASE = "https://api.bgm.tv";

// è·å–ç•ªå‰§æ•°æ®æ¨¡å¼
const ANIME_MODE = siteConfig.anime?.mode || "bangumi";

// è·å–å•ä¸ªæ¡ç›®ç›¸å…³äººå‘˜ä¿¡æ¯
async function fetchSubjectPersons(subjectId: number) {
	try {
		const response = await fetch(
			`${BANGUMI_API_BASE}/v0/subjects/${subjectId}/persons`,
		);
		const data = await response.json();
		return Array.isArray(data) ? data : [];
	} catch (error) {
		console.error(`Error fetching subject ${subjectId} persons:`, error);
		return [];
	}
}

// è·å–Bangumiæ”¶è—åˆ—è¡¨
async function fetchBangumiCollection(
	userId: string,
	subjectType: number,
	type: number,
) {
	try {
		let allData: any[] = [];
		let offset = 0;
		const limit = 50;
		let hasMore = true;

		while (hasMore) {
			const response = await fetch(
				`${BANGUMI_API_BASE}/v0/users/${userId}/collections?subject_type=${subjectType}&type=${type}&limit=${limit}&offset=${offset}`,
			);
			if (!response.ok) {
				throw new Error(`Bangumi API error: ${response.status}`);
			}
			const data = await response.json();

			if (data.data && data.data.length > 0) {
				allData = [...allData, ...data.data];
			}
			if (!data.data || data.data.length < limit) {
				hasMore = false;
			} else {
				offset += limit;
			}
			await new Promise((resolve) => setTimeout(resolve, 100));
		}
		return { data: allData };
	} catch (error) {
		console.error("Error fetching Bangumi data:", error);
		return null;
	}
}

// è·å–Bangumiæ•°æ®è½¬æ¢ä¸ºé¡µé¢æ‰€éœ€æ ¼å¼
async function processBangumiData(data: any, status: string) {
	if (!data || !data.data) return [];

	const detailedItems = await Promise.all(
		data.data.map(async (item: any) => {
			const subjectPersons = await fetchSubjectPersons(item.subject_id);
			const year = item.subject?.date || "Unknown";
			const rating = item.rate ? Number.parseFloat(item.rate.toFixed(1)) : 0;
			const progress = item.ep_status || 0;
			const totalEpisodes = item.subject?.eps || progress;

			let studio = "Unknown";
			if (Array.isArray(subjectPersons)) {
				const priorities = ["åŠ¨ç”»åˆ¶ä½œ", "è£½ä½œ", "åˆ¶ä½œ"];
				for (const relation of priorities) {
					const match = subjectPersons.find(
						(person) => person.relation === relation,
					);
					if (match?.name) {
						studio = match.name;
						break;
					}
				}
			}

			return {
				title: item.subject?.name_cn || item.subject?.name || "Unknown Title",
				status: status,
				rating: rating,
				cover: item.subject?.images?.medium || "/assets/anime/default.webp",
				description: (
					item.subject?.short_summary ||
					item.subject?.name_cn ||
					""
				).trimStart(),
				episodes: `${totalEpisodes} episodes`,
				year: year,
				genre: item.subject?.tags
					? item.subject.tags.slice(0, 3).map((tag: any) => tag.name)
					: ["Unknown"],
				studio: studio,
				link: item.subject?.id
					? `https://bgm.tv/subject/${item.subject.id}`
					: "#",
				progress: progress,
				totalEpisodes: totalEpisodes,
				startDate: item.subject?.date || "",
				endDate: item.subject?.date || "",
			};
		}),
	);
	return detailedItems;
}

// æ ¹æ®æ¨¡å¼è·å–ç•ªå‰§åˆ—è¡¨
let animeList: typeof localAnimeList = [];
if (ANIME_MODE === "local") {
	animeList = localAnimeList;
} else {
	const watchingData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 3);
	const plannedData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 1);
	const completedData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 2);
	const onHoldData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 4);
	const droppedData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 5);

	const watchingList = watchingData ? await processBangumiData(watchingData, "watching") : [];
	const plannedList = plannedData ? await processBangumiData(plannedData, "planned") : [];
	const completedList = completedData ? await processBangumiData(completedData, "completed") : [];
	const onHoldList = onHoldData ? await processBangumiData(onHoldData, "onhold") : [];
	const droppedList = droppedData ? await processBangumiData(droppedData, "dropped") : [];

	animeList = [
		...watchingList,
		...plannedList,
		...completedList,
		...onHoldList,
		...droppedList,
	];
}

// è·å–çŠ¶æ€çš„ç¿»è¯‘æ–‡æœ¬å’Œæ ·å¼
function getStatusInfo(status: string) {
	switch (status) {
		case "watching":
			return {
				text: i18n(I18nKey.animeStatusWatching),
				class:
					"bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300",
				icon: "â–¶",
			};
		case "completed":
			return {
				text: i18n(I18nKey.animeStatusCompleted),
				class:
					"bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300",
				icon: "âœ“",
			};
		case "planned":
			return {
				text: i18n(I18nKey.animeStatusPlanned),
				class:
					"bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-300",
				icon: "â°",
			};
		case "onhold":
			return {
				text: i18n(I18nKey.animeStatusOnHold),
				class:
					"bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-300",
				icon: "â¸",
			};
		case "dropped":
			return {
				text: i18n(I18nKey.animeStatusDropped),
				class: "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-300",
				icon: "âœ—",
			};
		default:
			return {
				text: status,
				class: "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300",
				icon: "?",
			};
	}
}

// è®¡ç®—ç»Ÿè®¡æ•°æ®
const stats = {
	total: animeList.length,
	watching: animeList.filter((anime) => anime.status === "watching").length,
	completed: animeList.filter((anime) => anime.status === "completed").length,
	avgRating: (() => {
		const ratedAnime = animeList.filter((anime) => anime.rating > 0);
		if (ratedAnime.length === 0) return "0.0";
		return (
			ratedAnime.reduce((sum, anime) => sum + anime.rating, 0) /
			ratedAnime.length
		).toFixed(1);
	})(),
};

// æ·»åŠ å½“å‰æ—¶é—´ä½œä¸ºæœ€åæ›´æ–°æ—¶é—´
const lastUpdated = new Date().toLocaleString('zh-CN', {
	year: 'numeric',
	month: 'numeric',
	day: 'numeric',
	hour: '2-digit',
	minute: '2-digit',
});

// å°†æ•°æ®ä¼ é€’ç»™å®¢æˆ·ç«¯è„šæœ¬
const animeData = JSON.stringify(animeList);
const statsData = JSON.stringify(stats);
const lastUpdatedStr = JSON.stringify(lastUpdated);

// åˆ†é¡µç›¸å…³å¸¸é‡
const ITEMS_PER_PAGE = 12;
const totalPages = Math.ceil(animeList.length / ITEMS_PER_PAGE);
const currentPage = 1; // é»˜è®¤ç¬¬ä¸€é¡µ
---

<MainGridLayout title={i18n(I18nKey.anime)} description={i18n(I18nKey.animeSubtitle)}>
  <div class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32">
    <div class="card-base z-10 px-9 py-6 relative w-full">
      <!-- é¡µé¢æ ‡é¢˜ -->
      <div class="relative w-full mb-8">
        <div class="mb-6">
          <h1 class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2 relative
                    before:w-1 before:h-8 before:rounded-md before:bg-[var(--primary)]
                    before:absolute before:top-1/2 before:-translate-y-1/2 before:-left-4">
            {i18n(I18nKey.animeTitle)}
          </h1>
          <p class="text-black/75 dark:text-white/75">{i18n(I18nKey.animeSubtitle)}</p>
        </div>

        <!-- ç»Ÿè®¡ä¿¡æ¯å¡ç‰‡ -->
        <div class="flex flex-wrap gap-3 mb-6">
          <div class="px-4 py-2 bg-white/80 dark:bg-gray-800/80 border border-gray-200 dark:border-gray-700 rounded-lg text-sm font-medium text-gray-800 dark:text-gray-200">
            æ€»æ•°ï¼š{stats.total}
          </div>
          <div class="px-4 py-2 bg-white/80 dark:bg-gray-800/80 border border-gray-200 dark:border-gray-700 rounded-lg text-sm font-medium text-gray-800 dark:text-gray-200">
            å¹³å‡è¯„åˆ†ï¼š{stats.avgRating}
          </div>
          <div class="px-4 py-2 bg-white/80 dark:bg-gray-800/80 border border-gray-200 dark:border-gray-700 rounded-lg text-sm font-medium text-gray-800 dark:text-gray-200">
            æœ€åæ›´æ–°ï¼š{lastUpdated}
          </div>
        </div>

        <!-- è¿‡æ»¤æŒ‰é’® - å‚è€ƒFireflyè®¾è®¡ -->
        <div class="mb-6">
          <div class="filter-container flex flex-wrap gap-2">
            <button class="filter-tag active" data-status="all">å…¨éƒ¨ ({stats.total})</button>
            <button class="filter-tag" data-status="watching">åœ¨çœ‹ ({stats.watching})</button>
            <button class="filter-tag" data-status="planned">æƒ³çœ‹ ({animeList.filter(a => a.status === 'planned').length})</button>
            <button class="filter-tag" data-status="completed">çœ‹è¿‡ ({stats.completed})</button>
            {ANIME_MODE === 'bangumi' && (
              <>
                <button class="filter-tag" data-status="onhold">æç½® ({animeList.filter(a => a.status === 'onhold').length})</button>
                <button class="filter-tag" data-status="dropped">æŠ›å¼ƒ ({animeList.filter(a => a.status === 'dropped').length})</button>
              </>
            )}
          </div>
        </div>
      </div>

      <!-- åŠ¨æ¼«åˆ—è¡¨ -->
      <div class="mb-8">
        {ANIME_MODE !== 'local' && BANGUMI_USER_ID === 'your-user-id' ? (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ˜¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
              {i18n(I18nKey.animeEmpty)}
            </h3>
            <p class="text-black/60 dark:text-white/60">
              è¯·åœ¨ src/config.ts æ–‡ä»¶ä¸­è®¾ç½®ä½ çš„ Bangumi ç”¨æˆ·ID
            </p>
          </div>
        ) : animeList.length > 0 ? (
          <div id="anime-list-container" class={`anime-grid-container grid gap-4 md:gap-6 list-mode ${
            isBothSidebarMode 
              ? "both-sidebar" 
              : "single-sidebar"
          }`} data-page="1">
            {animeList.map(anime => {
              const statusInfo = getStatusInfo(anime.status);
              const progressPercent = anime.totalEpisodes > 0 ? (anime.progress / anime.totalEpisodes) * 100 : 0;

              return (
                <div class="group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden transition-all duration-300 hover:shadow-lg hover:scale-[1.02]" data-anime-status={anime.status}>
                  <div class="relative aspect-[2/3] overflow-hidden">
                    <a href={anime.link} target="_blank" rel="noopener noreferrer" class="block w-full h-full">
                      <ImageWrapper 
                        src={anime.cover} 
                        alt={anime.title}
                        class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110"
                      />
                      <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                        <div class="absolute inset-0 flex items-center justify-center">
                          <div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
                            <svg class="w-6 h-6 text-gray-800 ml-1" fill="currentColor" viewBox="0 0 24 24">
                              <path d="M8 5v14l11-7z"/>
                            </svg>
                          </div>
                        </div>
                      </div>
                    </a>
                    
                    <div class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}`}>
                      <span class="mr-1">{statusInfo.icon}</span>
                      <span>{statusInfo.text}</span>
                    </div>
                    
                    <div class="absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded-md text-xs font-medium flex items-center gap-1">
                      <svg class="w-3 h-3 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                      </svg>
                      <span>{anime.rating}</span>
                    </div>
                    
                    {anime.status === 'watching' && (
                      <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-2">
                        <div class="w-full bg-white/20 rounded-full h-1.5 mb-1">
                          <div class="bg-gradient-to-r from-emerald-400 to-teal-400 h-1.5 rounded-full transition-all duration-300" style={`width: ${progressPercent}%`}></div>
                        </div>
                        <div class="text-white text-xs font-medium">
                          {anime.progress}/{anime.totalEpisodes} ({Math.round(progressPercent)}%)
                        </div>
                      </div>
                    )}
                  </div>
                  
                  <div class="p-3">
                    <h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 line-clamp-2 leading-tight">{anime.title}</h3>
                    <p class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2">{anime.description}</p>
                    
                    <div class="space-y-1 text-xs">
                      <div class="flex justify-between">
                        <span class="text-black/50 dark:text-white/50">{i18n(I18nKey.animeYear)}</span>
                        <span class="text-black/70 dark:text-white/70">{anime.year}</span>
                      </div>
                      <div class="flex justify-between">
                        <span class="text-black/50 dark:text-white/50">{i18n(I18nKey.animeStudio)}</span>
                        <span class="text-black/70 dark:text-white/70 truncate ml-2">{anime.studio}</span>
                      </div>
                      <div class="flex flex-wrap gap-1 mt-2">
                        {anime.genre.map(g => (
                          <span class="px-1.5 py-0.5 bg-[var(--btn-regular-bg)] text-black/70 dark:text-white/70 rounded text-xs">{g}</span>
                        ))}
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        ) : (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ˜¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
              {i18n(I18nKey.animeEmpty)}
            </h3>
            <p class="text-black/60 dark:text-white/60">
              {ANIME_MODE === 'local' ? i18n(I18nKey.animeEmptyLocal) : i18n(I18nKey.animeEmptyBangumi)}
            </p>
          </div>
        )}
      </div>

      <!-- åˆ†é¡µæ§ä»¶ -->
      {animeList.length > ITEMS_PER_PAGE && (
        <div class="flex justify-center items-center space-x-2 mt-6">
          <button class="px-3 py-1 border border-gray-300 dark:border-gray-600 rounded-md text-sm hover:bg-gray-100 dark:hover:bg-gray-700" onclick="prevPage()">ä¸Šä¸€é¡µ</button>
          <div class="flex space-x-1">
            {Array.from({ length: totalPages }, (_, i) => i + 1).map(page => (
              <button class={`px-3 py-1 rounded-md text-sm ${page === 1 ? 'bg-primary text-white' : 'hover:bg-gray-100 dark:hover:bg-gray-700'} transition-colors`}
                      onclick={`goToPage(${page})`}>{page}</button>
            ))}
          </div>
          <button class="px-3 py-1 border border-gray-300 dark:border-gray-600 rounded-md text-sm hover:bg-gray-100 dark:hover:bg-gray-700" onclick="nextPage()">ä¸‹ä¸€é¡µ</button>
        </div>
      )}
    </div>
  </div>

  <script is:inline define:vars={{ isBothSidebarMode, animeData, statsData, lastUpdatedStr }}>
    // åˆå§‹åŒ–å…¨å±€å˜é‡
    window.animeData = JSON.parse(animeData);
    window.statsData = JSON.parse(statsData);
    window.lastUpdated = JSON.parse(lastUpdatedStr);
    window.ITEMS_PER_PAGE = ITEMS_PER_PAGE;
    window.currentPage = 1;
    window.totalPages = Math.ceil(window.animeData.length / ITEMS_PER_PAGE);
    window.filteredData = window.animeData;
    window.currentFilter = "all";

    // åˆå§‹æ¸²æŸ“
    renderAnimeList();

    // åˆ†é¡µå‡½æ•°
    function goToPage(page) {
      if (page < 1 || page > window.totalPages) return;
      window.currentPage = page;
      renderAnimeList();
    }

    function prevPage() {
      if (window.currentPage > 1) {
        window.currentPage--;
        renderAnimeList();
      }
    }

    function nextPage() {
      if (window.currentPage < window.totalPages) {
        window.currentPage++;
        renderAnimeList();
      }
    }

    // æ¸²æŸ“åŠ¨æ¼«åˆ—è¡¨
    function renderAnimeList() {
      const container = document.getElementById("anime-list-container");
      if (!container) return;

      const start = (window.currentPage - 1) * window.ITEMS_PER_PAGE;
      const end = start + window.ITEMS_PER_PAGE;
      const paginatedData = window.filteredData.slice(start, end);

      // æ›´æ–°å®¹å™¨çš„ data-page å±æ€§
      container.setAttribute("data-page", window.currentPage);

      // æ¸…ç©ºå¹¶é‡æ–°å¡«å……
      container.innerHTML = '';
      paginatedData.forEach(anime => {
        const statusInfo = getStatusInfo(anime.status);
        const progressPercent = anime.totalEpisodes > 0 ? (anime.progress / anime.totalEpisodes) * 100 : 0;

        const card = document.createElement('div');
        card.className = `group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden transition-all duration-300 hover:shadow-lg hover:scale-[1.02]`;
        card.dataset.animeStatus = anime.status;

        card.innerHTML = `
          <div class="relative aspect-[2/3] overflow-hidden">
            <a href="${anime.link}" target="_blank" rel="noopener noreferrer" class="block w-full h-full">
              <img src="${anime.cover}" alt="${anime.title}" class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110" />
              <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                <div class="absolute inset-0 flex items-center justify-center">
                  <div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
                    <svg class="w-6 h-6 text-gray-800 ml-1" fill="currentColor" viewBox="0 0 24 24">
                      <path d="M8 5v14l11-7z"/>
                    </svg>
                  </div>
                </div>
              </div>
            </a>
            
            <div class="absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}">
              <span class="mr-1">${statusInfo.icon}</span>
              <span>${statusInfo.text}</span>
            </div>
            
            <div class="absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded-md text-xs font-medium flex items-center gap-1">
              <svg class="w-3 h-3 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
              </svg>
              <span>${anime.rating}</span>
            </div>
            
            ${anime.status === 'watching' ? `
              <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-2">
                <div class="w-full bg-white/20 rounded-full h-1.5 mb-1">
                  <div class="bg-gradient-to-r from-emerald-400 to-teal-400 h-1.5 rounded-full transition-all duration-300" style="width: ${progressPercent}%"></div>
                </div>
                <div class="text-white text-xs font-medium">
                  ${anime.progress}/${anime.totalEpisodes} (${Math.round(progressPercent)}%)
                </div>
              </div>
            ` : ''}
          </div>
          
          <div class="p-3">
            <h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 line-clamp-2 leading-tight">${anime.title}</h3>
            <p class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2">${anime.description}</p>
            
            <div class="space-y-1 text-xs">
              <div class="flex justify-between">
                <span class="text-black/50 dark:text-white/50">${i18n(I18nKey.animeYear)}</span>
                <span class="text-black/70 dark:text-white/70">${anime.year}</span>
              </div>
              <div class="flex justify-between">
                <span class="text-black/50 dark:text-white/50">${i18n(I18nKey.animeStudio)}</span>
                <span class="text-black/70 dark:text-white/70 truncate ml-2">${anime.studio}</span>
              </div>
              <div class="flex flex-wrap gap-1 mt-2">
                ${anime.genre.map(g => `<span class="px-1.5 py-0.5 bg-[var(--btn-regular-bg)] text-black/70 dark:text-white/70 rounded text-xs">${g}</span>`).join('')}
              </div>
            </div>
          </div>
        `;

        container.appendChild(card);
      });

      // æ›´æ–°åˆ†é¡µæŒ‰é’®çŠ¶æ€
      const prevBtn = document.querySelector('.pagination .prev');
      const nextBtn = document.querySelector('.pagination .next');
      if (prevBtn) prevBtn.disabled = window.currentPage <= 1;
      if (nextBtn) nextBtn.disabled = window.currentPage >= window.totalPages;
    }

    // è¿‡æ»¤åŠŸèƒ½åˆå§‹åŒ–
    function initFilterButtons() {
      const filterTags = document.querySelectorAll('.filter-tag');
      filterTags.forEach(tag => {
        tag.addEventListener('click', function() {
          const status = this.getAttribute('data-status');
          window.currentFilter = status;

          // æ›´æ–°æ‰€æœ‰æŒ‰é’®çŠ¶æ€
          filterTags.forEach(t => t.classList.remove('active'));
          this.classList.add('active');

          // è¿‡æ»¤æ•°æ®
          if (status === 'all') {
            window.filteredData = window.animeData;
          } else {
            window.filteredData = window.animeData.filter(anime => anime.status === status);
          }

          // é‡ç½®åˆ†é¡µ
          window.currentPage = 1;
          window.totalPages = Math.ceil(window.filteredData.length / window.ITEMS_PER_PAGE);

          // é‡æ–°æ¸²æŸ“
          renderAnimeList();
        });
      });
    }

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', () => {
      initFilterButtons();
      setupSwupListeners();
    });

    // Swup ç›‘å¬å™¨
    function setupSwupListeners() {
      if (window.swup) {
        window.swup.hooks.on('content:replace', () => {
          setTimeout(() => {
            initFilterButtons();
            renderAnimeList();
          }, 150);
        });
      }
    }

    // ç«‹å³æ‰§è¡Œåˆå§‹åŒ–
    if (typeof window !== 'undefined') {
      if (window.swup) {
        setupSwupListeners();
      } else {
        document.addEventListener('swup:enable', setupSwupListeners);
      }
    }
  </script>

  <!-- è¿‡æ»¤æŒ‰é’®æ ·å¼ -->
  <style>
    /* å®¹å™¨æŸ¥è¯¢æ”¯æŒ */
    .card-base {
      container-type: inline-size;
    }
    
    .anime-grid-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .anime-grid-container.single-sidebar {
      @container (min-width: 900px) {
        grid-template-columns: repeat(5, 1fr);
      }
      
      @container (min-width: 600px) and (max-width: 899px) {
        grid-template-columns: repeat(3, 1fr);
      }
      
      @container (max-width: 599px) {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    
    .anime-grid-container.both-sidebar {
      @container (min-width: 950px) {
        grid-template-columns: repeat(5, 1fr);
      }
      
      @container (min-width: 650px) and (max-width: 949px) {
        grid-template-columns: repeat(4, 1fr);
      }
      
      @container (min-width: 480px) and (max-width: 649px) {
        grid-template-columns: repeat(3, 1fr);
      }
      
      @container (max-width: 479px) {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    
    .filter-container {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    
    .filter-tag {
      padding: 0.5rem 1rem;
      border: 1px solid var(--line-divider);
      border-radius: var(--radius-large);
      background: var(--btn-regular-bg);
      color: var(--btn-content);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }
    
    .filter-tag:hover:not(.active) {
      background: var(--btn-hover-bg);
      border-color: var(--primary);
      transform: translateY(-1px);
    }
    
    .filter-tag.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }
    
    .filter-tag.active:hover {
      background: var(--primary) !important;
      color: white !important;
      border-color: var(--primary) !important;
      transform: translateY(-1px);
    }
    
    [data-anime-status] {
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    #anime-list-container.grid-mode [data-anime-status]:hover {
      transform: translateY(-8px) scale(1.02);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15);
      z-index: 10;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    #anime-list-container.list-mode [data-anime-status]:hover {
      transform: translateX(8px) scale(1.01);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
      z-index: 10;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    [data-anime-status].anime-hidden {
      display: none;
    }
    
    [data-anime-status].anime-animating {
      transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1),
                  opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    [data-anime-status].anime-fade-out {
      opacity: 0;
      transform: scale(0.8);
      pointer-events: none;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                  transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    [data-anime-status].anime-fade-in {
      opacity: 0;
      transform: scale(0.8);
    }
    
    [data-anime-status].anime-fade-in-active {
      opacity: 1;
      transform: scale(1);
    }
  </style>
</MainGridLayout>
