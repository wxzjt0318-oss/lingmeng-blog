---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import { sidebarLayoutConfig, siteConfig } from "../config";
import localAnimeList from "../data/anime";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";
import MainGridLayout from "../layouts/MainGridLayout.astro";

// æ£€æŸ¥ç•ªå‰§é¡µé¢æ˜¯å¦å¯ç”¨
if (!siteConfig.featurePages.anime) {
	return Astro.redirect("/404/");
}

const isBothSidebarMode = sidebarLayoutConfig.position === "both";
const BANGUMI_USER_ID = siteConfig.bangumi?.userId || "your-user-id";
const BANGUMI_API_BASE = "https://api.bgm.tv/v0";
const ANIME_MODE = siteConfig.anime?.mode || "bangumi";

// å®‰å…¨è·å–æ„å»ºæ—¶é—´ï¼ˆéƒ¨ç½²æ—¶é—´ï¼‰
const rawBuildTime = import.meta.env.BUILD_TIME;
let BUILD_TIME: string | null = null;
if (rawBuildTime) {
	const parsed = new Date(rawBuildTime);
	if (!isNaN(parsed.getTime())) {
		BUILD_TIME = parsed.toLocaleString('zh-CN', {
			year: 'numeric',
			month: '2-digit',
			day: '2-digit',
			hour: '2-digit',
			minute: '2-digit',
			hour12: false
		});
	}
}

// æœ€åæ›´æ–°æ—¶é—´ & é”™è¯¯ä¿¡æ¯
let lastUpdateTime: string | null = BUILD_TIME;
let bangumiError: string | null = null;

// å·¥å…·å‡½æ•°ï¼šå®‰å…¨ fetch
async function safeFetch(url: string, options: RequestInit = {}) {
	try {
		const res = await fetch(url, { ...options, timeout: 10000 });
		if (res.status === 404) return { error: "USER_NOT_FOUND" };
		if (res.status === 429) return { error: "RATE_LIMITED" };
		if (!res.ok) throw new Error(`HTTP ${res.status}`);
		return { data: await res.json() };
	} catch (err) {
		console.error("Fetch error:", err);
		return { error: "NETWORK_ERROR" };
	}
}

// è·å–åˆ¶ä½œå…¬å¸
function extractStudio(persons: any[]): string {
	if (!Array.isArray(persons)) return "Unknown";
	const priorities = ["åŠ¨ç”»åˆ¶ä½œ", "è£½ä½œ", "åˆ¶ä½œ"];
	for (const relation of priorities) {
		const match = persons.find((p: any) => p.relation === relation);
		if (match?.name) return match.name;
	}
	return "Unknown";
}

// è·å–ç”¨æˆ·æ”¶è—ï¼ˆå¸¦åˆ†é¡µï¼‰
async function fetchUserCollections(userId: string, subjectType: number, type: number) {
	let allData: any[] = [];
	let offset = 0;
	const limit = 50;

	while (true) {
		const { data, error } = await safeFetch(
			`${BANGUMI_API_BASE}/users/${userId}/collections?subject_type=${subjectType}&type=${type}&limit=${limit}&offset=${offset}`
		);

		if (error) return { error };
		if (!data?.data || !Array.isArray(data.data)) break;

		allData.push(...data.data);
		if (data.data.length < limit) break;
		offset += limit;
		await new Promise(r => setTimeout(r, 150)); // é˜²é™æµ
	}

	return { data: allData };
}

// å¤„ç†å•ä¸ªæ¡ç›®
function processItem(item: any, status: string) {
	const subject = item.subject || {};
	const year = subject.date?.slice(0, 4) || "Unknown";
	const rating = item.rate ? parseFloat(item.rate.toFixed(1)) : 0;
	const progress = item.ep_status || 0;
	const totalEpisodes = subject.eps || progress;
	const studio = extractStudio(item.subject_persons || []);

	return {
		title: subject.name_cn || subject.name || "Unknown Title",
		status,
		rating,
		cover: subject.images?.medium || "/assets/anime/default.webp",
		description: (subject.summary || subject.name_cn || "").trim(),
		episodes: `${totalEpisodes} episodes`,
		year,
		genre: Array.isArray(subject.tags) ? subject.tags.slice(0, 3).map((t: any) => t.name) : ["Unknown"],
		studio,
		link: subject.id ? `https://bgm.tv/subject/${subject.id}` : "#",
		progress,
		totalEpisodes,
	};
}

// å¹¶è¡Œè·å–æ‰€æœ‰çŠ¶æ€æ•°æ®
let animeList: typeof localAnimeList = [];
if (ANIME_MODE === "local") {
	animeList = localAnimeList;
} else if (BANGUMI_USER_ID !== "your-user-id") {
	const statuses = [
		{ type: 3, status: "watching" },
		{ type: 1, status: "planned" },
		{ type: 2, status: "completed" },
		{ type: 4, status: "onhold" },
		{ type: 5, status: "dropped" }
	];

	const results = await Promise.all(
		statuses.map(async ({ type, status }) => {
			const res = await fetchUserCollections(BANGUMI_USER_ID, 2, type);
			if (res.error) return { error: res.error, status };
			return { data: res.data, status };
		})
	);

	// æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯
	const firstError = results.find(r => r.error);
	if (firstError) {
		bangumiError = firstError.error;
	} else {
		// åˆå¹¶æ•°æ®
		animeList = results.flatMap(({ data, status }) =>
			data.map((item: any) => processItem(item, status))
		);
	}
}

// ç»Ÿè®¡ä¿¡æ¯ï¼ˆä»…è®¡ç®—ä¸€æ¬¡ï¼‰
const stats = (() => {
	const watching = animeList.filter(a => a.status === "watching").length;
	const completed = animeList.filter(a => a.status === "completed").length;
	const planned = animeList.filter(a => a.status === "planned").length;
	const onhold = animeList.filter(a => a.status === "onhold").length;
	const dropped = animeList.filter(a => a.status === "dropped").length;
	const total = animeList.length;
	const avgRating = (() => {
		const rated = animeList.filter(a => a.rating > 0);
		return rated.length ? (rated.reduce((sum, a) => sum + a.rating, 0) / rated.length).toFixed(1) : "0.0";
	})();
	return { total, watching, completed, planned, onhold, dropped, avgRating };
})();

// å›½é™…åŒ–æ–‡æœ¬
const i18nTexts = {
	year: i18n(I18nKey.animeYear),
	studio: i18n(I18nKey.animeStudio),
	watching: i18n(I18nKey.animeStatusWatching),
	completed: i18n(I18nKey.animeStatusCompleted),
	planned: i18n(I18nKey.animeStatusPlanned),
	onhold: i18n(I18nKey.animeStatusOnHold),
	dropped: i18n(I18nKey.animeStatusDropped),
	userNotFound: i18n(I18nKey.animeErrorUserNotFound),
	rateLimited: i18n(I18nKey.animeErrorRateLimited),
	networkError: i18n(I18nKey.animeErrorNetwork),
	userIdInvalid: i18n(I18nKey.animeErrorUserIdInvalid),
	filterAll: i18n(I18nKey.animeFilterAll),
};

// çŠ¶æ€æ ·å¼æ˜ å°„
function getStatusInfo(status: string) {
	const map: Record<string, { text: string; class: string; icon: string }> = {
		watching: { text: i18nTexts.watching, class: "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300", icon: "â–¶" },
		completed: { text: i18nTexts.completed, class: "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300", icon: "âœ“" },
		planned: { text: i18nTexts.planned, class: "bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-300", icon: "â°" },
		onhold: { text: i18nTexts.onhold, class: "bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-300", icon: "â¸" },
		dropped: { text: i18nTexts.dropped, class: "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-300", icon: "âœ—" },
	};
	return map[status] || { text: status, class: "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300", icon: "?" };
}
---

<MainGridLayout title={i18n(I18nKey.anime)} description={i18n(I18nKey.animeSubtitle)}>
  <div class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32">
    <div class="card-base z-10 px-9 py-6 relative w-full">
      <!-- æ ‡é¢˜ -->
      <div class="relative w-full mb-8">
        <div class="mb-6">
          <h1 class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2 relative before:w-1 before:h-8 before:rounded-md before:bg-[var(--primary)] before:absolute before:top-1/2 before:-translate-y-1/2 before:-left-4">
            {i18n(I18nKey.animeTitle)}
          </h1>
          <p class="text-black/75 dark:text-white/75">{i18n(I18nKey.animeSubtitle)}</p>
        </div>

        <!-- ç»Ÿè®¡ä¿¡æ¯ -->
        <div class="mb-6 flex flex-wrap gap-4 text-sm">
          <div class="px-3 py-2 bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-md">
            <span class="text-black/60 dark:text-white/60">æ€»æ•°ï¼š</span>
            <span class="font-medium">{stats.total}</span>
          </div>
          <div class="px-3 py-2 bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-md">
            <span class="text-black/60 dark:text-white/60">å¹³å‡è¯„åˆ†ï¼š</span>
            <span class="font-medium">{stats.avgRating}</span>
          </div>
          {lastUpdateTime && (
            <div class="px-3 py-2 bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-md">
              <span class="text-black/60 dark:text-white/60">æœ€åæ›´æ–°ï¼š</span>
              <span class="font-medium">{lastUpdateTime}</span>
            </div>
          )}
        </div>

        <!-- è¿‡æ»¤æŒ‰é’® -->
        <div class="mb-6">
          <div class="filter-container flex flex-wrap gap-2">
            <button 
              class="filter-tag active" 
              data-status="all"
              aria-label={`æ˜¾ç¤ºå…¨éƒ¨ ${stats.total} éƒ¨`}
            >
              {i18nTexts.filterAll} ({stats.total})
            </button>
            <button 
              class="filter-tag" 
              data-status="watching"
              aria-label={`æ­£åœ¨çœ‹ ${stats.watching} éƒ¨`}
            >
              {i18nTexts.watching} ({stats.watching})
            </button>
            <button 
              class="filter-tag" 
              data-status="planned"
              aria-label={`æƒ³çœ‹ ${stats.planned} éƒ¨`}
            >
              {i18nTexts.planned} ({stats.planned})
            </button>
            <button 
              class="filter-tag" 
              data-status="completed"
              aria-label={`å·²çœ‹å®Œ ${stats.completed} éƒ¨`}
            >
              {i18nTexts.completed} ({stats.completed})
            </button>
            {ANIME_MODE === 'bangumi' && (
              <>
                <button 
                  class="filter-tag" 
                  data-status="onhold"
                  aria-label={`æç½® ${stats.onhold} éƒ¨`}
                >
                  {i18nTexts.onhold} ({stats.onhold})
                </button>
                <button 
                  class="filter-tag" 
                  data-status="dropped"
                  aria-label={`æ”¾å¼ƒ ${stats.dropped} éƒ¨`}
                >
                  {i18nTexts.dropped} ({stats.dropped})
                </button>
              </>
            )}
          </div>
        </div>
      </div>

      <!-- åŠ¨æ¼«åˆ—è¡¨ -->
      <div class="mb-8">
        {ANIME_MODE !== 'local' && BANGUMI_USER_ID === 'your-user-id' ? (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ˜¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">{i18n(I18nKey.animeEmpty)}</h3>
            <p class="text-black/60 dark:text-white/60">{i18nTexts.userIdInvalid}</p>
          </div>
        ) : bangumiError ? (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">âš ï¸</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
              {bangumiError === 'USER_NOT_FOUND'
                ? i18nTexts.userNotFound
                : bangumiError === 'RATE_LIMITED'
                  ? i18nTexts.rateLimited
                  : i18nTexts.networkError}
            </h3>
            <p class="text-black/60 dark:text-white/60 mt-2">
              {bangumiError === 'USER_NOT_FOUND'
                ? `ç”¨æˆ· ID "${BANGUMI_USER_ID}" æ— æ•ˆ`
                : 'è¯·ç¨ååˆ·æ–°é¡µé¢æˆ–è”ç³»ç«™ç‚¹ç®¡ç†å‘˜'}
            </p>
          </div>
        ) : animeList.length > 0 ? (
          <>
            <div id="anime-list-container" class={`anime-grid-container grid gap-4 md:gap-6 list-mode ${isBothSidebarMode ? "both-sidebar" : "single-sidebar"}`}></div>
            <div id="pagination-controls" class="mt-6 flex justify-center gap-2 flex-wrap"></div>
          </>
        ) : (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ˜¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">{i18n(I18nKey.animeEmpty)}</h3>
            <p class="text-black/60 dark:text-white/60">
              {ANIME_MODE === 'local' ? i18n(I18nKey.animeEmptyLocal) : i18n(I18nKey.animeEmptyBangumi)}
            </p>
          </div>
        )}
      </div>
    </div>
  </div>

  <script is:inline define:vars={{ animeList, isBothSidebarMode, i18nTexts, stats }}>
    let currentFilteredAnime = [...animeList];
    const pageSize = 20;
    let currentPage = 1;

    function renderPagination(totalItems) {
      const totalPages = Math.ceil(totalItems / pageSize);
      const container = document.getElementById('pagination-controls');
      if (!container) return;
      container.innerHTML = '';
      if (totalPages <= 1) return;

      const createBtn = (text, page, isActive = false) => {
        const btn = document.createElement('button');
        btn.className = `px-3 py-1 rounded-md text-sm transition ${
          isActive 
            ? 'bg-[var(--primary)] text-white' 
            : 'bg-[var(--btn-regular-bg)] text-[var(--btn-content)] hover:bg-[var(--btn-hover-bg)]'
        }`;
        btn.textContent = text;
        if (page !== undefined) {
          btn.onclick = () => {
            currentPage = page;
            renderAnimeList();
            renderPagination(currentFilteredAnime.length);
            document.querySelector('#anime-list-container')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
          };
        }
        return btn;
      };

      // ä¸Šä¸€é¡µ
      if (currentPage > 1) container.appendChild(createBtn('â€¹', currentPage - 1));
      
      // é¡µç ï¼ˆæœ€å¤šæ˜¾ç¤º 5 ä¸ªï¼‰
      const start = Math.max(1, currentPage - 2);
      const end = Math.min(totalPages, start + 4);
      for (let i = start; i <= end; i++) {
        container.appendChild(createBtn(i.toString(), i, i === currentPage));
      }

      // ä¸‹ä¸€é¡µ
      if (currentPage < totalPages) container.appendChild(createBtn('â€º', currentPage + 1));
    }

    function renderAnimeList() {
      const container = document.getElementById('anime-list-container');
      if (!container) return;

      const startIndex = (currentPage - 1) * pageSize;
      const paginatedItems = currentFilteredAnime.slice(startIndex, startIndex + pageSize);

      container.innerHTML = paginatedItems.map(anime => {
        const statusInfo = getStatusInfo(anime.status);
        const progressPercent = anime.totalEpisodes > 0 ? (anime.progress / anime.totalEpisodes) * 100 : 0;

        return `
          <div class="group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden transition-all duration-300 hover:shadow-lg hover:scale-[1.02]" data-anime-status="${anime.status}">
            <div class="relative aspect-[2/3] overflow-hidden">
              <a href="${anime.link}" target="_blank" rel="noopener noreferrer" class="block w-full h-full">
                <img src="${anime.cover}" alt="${anime.title.replace(/"/g, '&quot;')}" class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110" loading="lazy" />
                <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                  <div class="absolute inset-0 flex items-center justify-center">
                    <div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
                      <svg class="w-6 h-6 text-gray-800 ml-1" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                    </div>
                  </div>
                </div>
              </a>
              <div class="absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}">
                <span class="mr-1">${statusInfo.icon}</span><span>${statusInfo.text}</span>
              </div>
              <div class="absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded-md text-xs font-medium flex items-center gap-1">
                <svg class="w-3 h-3 text-yellow-400" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/></svg>
                <span>${anime.rating}</span>
              </div>
              ${anime.status === 'watching' ? `
                <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-2">
                  <div class="w-full bg-white/20 rounded-full h-1.5 mb-1">
                    <div class="bg-gradient-to-r from-emerald-400 to-teal-400 h-1.5 rounded-full" style="width: ${progressPercent}%"></div>
                  </div>
                  <div class="text-white text-xs font-medium">${anime.progress}/${anime.totalEpisodes} (${Math.round(progressPercent)}%)</div>
                </div>` : ''}
            </div>
            <div class="p-3">
              <h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 line-clamp-2 leading-tight">${anime.title}</h3>
              <p class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2">${anime.description}</p>
              <div class="space-y-1 text-xs">
                <div class="flex justify-between"><span class="text-black/50 dark:text-white/50">${i18nTexts.year}</span><span class="text-black/70 dark:text-white/70">${anime.year}</span></div>
                <div class="flex justify-between"><span class="text-black/50 dark:text-white/50">${i18nTexts.studio}</span><span class="text-black/70 dark:text-white/70 truncate ml-2">${anime.studio}</span></div>
                <div class="flex flex-wrap gap-1 mt-2">
                  ${anime.genre.map(g => `<span class="px-1.5 py-0.5 bg-[var(--btn-regular-bg)] text-black/70 dark:text-white/70 rounded text-xs">${g}</span>`).join('')}
                </div>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    function getStatusInfo(status) {
      const map = {
        watching: { text: i18nTexts.watching, class: "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300", icon: "â–¶" },
        completed: { text: i18nTexts.completed, class: "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300", icon: "âœ“" },
        planned: { text: i18nTexts.planned, class: "bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-300", icon: "â°" },
        onhold: { text: i18nTexts.onhold, class: "bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-300", icon: "â¸" },
        dropped: { text: i18nTexts.dropped, class: "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-300", icon: "âœ—" }
      };
      return map[status] || { text: status, class: "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300", icon: "?" };
    }

    function updateFilterCounts() {
      const tags = document.querySelectorAll('.filter-tag');
      tags.forEach(tag => {
        const status = tag.getAttribute('data-status');
        if (!status) return;
        const count = stats[status as keyof typeof stats] ?? (status === 'all' ? stats.total : 0);
        const originalText = tag.textContent?.split('(')[0]?.trim() || '';
        tag.textContent = `${originalText} (${count})`;
        tag.setAttribute('data-count', String(count));
      });
    }

    function initFilterButtons() {
      const tags = document.querySelectorAll('.filter-tag');
      tags.forEach(tag => {
        tag.addEventListener('click', () => {
          tags.forEach(t => t.classList.remove('active'));
          tag.classList.add('active');

          const status = tag.getAttribute('data-status');
          currentFilteredAnime = status === 'all' ? [...animeList] : animeList.filter(a => a.status === status);
          currentPage = 1;
          renderAnimeList();
          renderPagination(currentFilteredAnime.length);
          updateFilterCounts();
        });
      });
      updateFilterCounts();
    }

    document.addEventListener('DOMContentLoaded', () => {
      renderAnimeList();
      renderPagination(animeList.length);
      initFilterButtons();
    });
  </script>

 <style>
  .card-base { 
    container-type: inline-size; 
  }

  .anime-grid-container {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  }
  .anime-grid-container *,
  .anime-grid-container *::before,
  .anime-grid-container *::after {
    font-family: inherit;
  }

  .anime-grid-container.single-sidebar {
    @container (min-width: 900px) { grid-template-columns: repeat(5, 1fr); }
    @container (min-width: 600px) and (max-width: 899px) { grid-template-columns: repeat(3, 1fr); }
    @container (max-width: 599px) { grid-template-columns: repeat(2, 1fr); }
  }
  .anime-grid-container.both-sidebar {
    @container (min-width: 950px) { grid-template-columns: repeat(5, 1fr); }
    @container (min-width: 650px) and (max-width: 949px) { grid-template-columns: repeat(4, 1fr); }
    @container (min-width: 480px) and (max-width: 649px) { grid-template-columns: repeat(3, 1fr); }
    @container (max-width: 479px) { grid-template-columns: repeat(2, 1fr); }
  }

  .filter-container { 
    display: flex; 
    flex-wrap: wrap; 
    gap: 0.5rem; 
  }
  .filter-tag {
    padding: 0.5rem 1rem;
    border: 1px solid var(--line-divider);
    border-radius: var(--radius-large);
    background: var(--btn-regular-bg);
    color: var(--btn-content);
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
  }
  .filter-tag:hover:not(.active) {
    background: var(--btn-hover-bg);
    border-color: var(--primary);
    transform: translateY(-1px);
  }
  .filter-tag.active {
    background: var(--primary);
    color: white;
    border-color: var(--primary);
  }

  [data-anime-status] { 
    transition: all 0.3s ease; 
  }
</style>
</MainGridLayout>
