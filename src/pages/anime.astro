---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import { sidebarLayoutConfig, siteConfig } from "../config";
import localAnimeList from "../data/anime";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";
import MainGridLayout from "../layouts/MainGridLayout.astro";

// æ£€æŸ¥ç•ªå‰§é¡µé¢æ˜¯å¦å¯ç”¨
if (!siteConfig.featurePages.anime) {
	return Astro.redirect("/404/");
}

const isBothSidebarMode = sidebarLayoutConfig.position === "both";
const BANGUMI_USER_ID = siteConfig.bangumi?.userId || "your-user-id";
const BANGUMI_API_BASE = "https://api.bgm.tv";
const ANIME_MODE = siteConfig.anime?.mode || "bangumi";

// --- API å‡½æ•°ï¼ˆä¿æŒä¸å˜ï¼‰ ---
async function fetchSubjectPersons(subjectId: number) {
	try {
		const response = await fetch(`${BANGUMI_API_BASE}/v0/subjects/${subjectId}/persons`);
		const data = await response.json();
		return Array.isArray(data) ? data : [];
	} catch (error) {
		console.error(`Error fetching subject ${subjectId} persons:`, error);
		return [];
	}
}

async function fetchBangumiCollection(userId: string, subjectType: number, type: number) {
	try {
		let allData: any[] = [];
		let offset = 0;
		const limit = 50;
		let hasMore = true;

		while (hasMore) {
			const response = await fetch(
				`${BANGUMI_API_BASE}/v0/users/${userId}/collections?subject_type=${subjectType}&type=${type}&limit=${limit}&offset=${offset}`
			);
			if (!response.ok) throw new Error(`Bangumi API error: ${response.status}`);
			const data = await response.json();

			if (data.data && data.data.length > 0) {
				allData = [...allData, ...data.data];
			}
			if (!data.data || data.data.length < limit) hasMore = false;
			else offset += limit;
			await new Promise(resolve => setTimeout(resolve, 100));
		}
		return { data: allData };
	} catch (error) {
		console.error("Error fetching Bangumi data:", error);
		return null;
	}
}

async function processBangumiData(data: any, status: string) {
	if (!data || !data.data) return [];

	const detailedItems = await Promise.all(
		data.data.map(async (item: any) => {
			const subjectPersons = await fetchSubjectPersons(item.subject_id);
			const year = item.subject?.date || "Unknown";
			const rating = item.rate ? Number.parseFloat(item.rate.toFixed(1)) : 0;
			const progress = item.ep_status || 0;
			const totalEpisodes = item.subject?.eps || progress;

			let studio = "Unknown";
			const priorities = ["åŠ¨ç”»åˆ¶ä½œ", "è£½ä½œ", "åˆ¶ä½œ"];
			for (const relation of priorities) {
				const match = subjectPersons.find(p => p.relation === relation);
				if (match?.name) {
					studio = match.name;
					break;
				}
			}

			return {
				title: item.subject?.name_cn || item.subject?.name || "Unknown Title",
				status,
				rating,
				cover: item.subject?.images?.medium || "/assets/anime/default.webp",
				description: (item.subject?.short_summary || item.subject?.name_cn || "").trimStart(),
				episodes: `${totalEpisodes} episodes`,
				year,
				genre: item.subject?.tags ? item.subject.tags.slice(0, 3).map((tag: any) => tag.name) : ["Unknown"],
				studio,
				link: item.subject?.id ? `https://bgm.tv/subject/${item.subject.id}` : "#",
				progress,
				totalEpisodes,
				startDate: item.subject?.date || "",
				endDate: item.subject?.date || "",
			};
		})
	);
	return detailedItems;
}

// --- è·å–åŠ¨æ¼«åˆ—è¡¨ ---
let animeList: typeof localAnimeList = [];
if (ANIME_MODE === "local") {
	animeList = localAnimeList;
} else {
	const watchingData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 3);
	const plannedData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 1);
	const completedData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 2);
	const onHoldData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 4);
	const droppedData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 5);

	const watchingList = watchingData ? await processBangumiData(watchingData, "watching") : [];
	const plannedList = plannedData ? await processBangumiData(plannedData, "planned") : [];
	const completedList = completedData ? await processBangumiData(completedData, "completed") : [];
	const onHoldList = onHoldData ? await processBangumiData(onHoldData, "onhold") : [];
	const droppedList = droppedData ? await processBangumiData(droppedData, "dropped") : [];

	animeList = [
		...watchingList,
		...plannedList,
		...completedList,
		...onHoldList,
		...droppedList,
	];
}

// --- æ¸¸æˆåˆ—è¡¨ï¼ˆç¤ºä¾‹æ•°æ®ï¼‰---
const gameList = [
	{
		title: "å¡å°”è¾¾ä¼ è¯´ï¼šæ—·é‡ä¹‹æ¯",
		description: "å¼€æ”¾ä¸–ç•Œå†’é™©æ¸¸æˆï¼Œæ¢ç´¢æµ·æ‹‰é²å¤§é™†çš„æ¯ä¸€ä¸ªè§’è½ã€‚",
	},
	{
		title: "æ˜Ÿéœ²è°·ç‰©è¯­",
		description: "ç»è¥ä½ çš„å†œåœºï¼Œä¸æ‘æ°‘å»ºç«‹å‹è°Šï¼Œä½“éªŒå®é™ä¹¡æ‘ç”Ÿæ´»ã€‚",
	},
];

// --- çŠ¶æ€æ˜ å°„ ---
function getStatusInfo(status: string) {
	switch (status) {
		case "watching":
			return { text: i18n(I18nKey.animeStatusWatching), class: "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300", icon: "â–¶" };
		case "completed":
			return { text: i18n(I18nKey.animeStatusCompleted), class: "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300", icon: "âœ“" };
		case "planned":
			return { text: i18n(I18nKey.animeStatusPlanned), class: "bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-300", icon: "â°" };
		case "onhold":
			return { text: i18n(I18nKey.animeStatusOnHold), class: "bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-300", icon: "â¸" };
		case "dropped":
			return { text: i18n(I18nKey.animeStatusDropped), class: "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-300", icon: "âœ—" };
		default:
			return { text: status, class: "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300", icon: "?" };
	}
}

// --- ç»Ÿè®¡ ---
const stats = {
	total: animeList.length,
	watching: animeList.filter(a => a.status === "watching").length,
	completed: animeList.filter(a => a.status === "completed").length,
	avgRating: (() => {
		const rated = animeList.filter(a => a.rating > 0);
		return rated.length === 0 ? "0.0" : (rated.reduce((s, a) => s + a.rating, 0) / rated.length).toFixed(1);
	})(),
};

const gameStats = { total: gameList.length };

// --- åˆ†é¡µé€»è¾‘ ---
const itemsPerPage = 12;
const totalPages = Math.max(1, Math.ceil(animeList.length / itemsPerPage));
const currentPage = 1; // å¯æ‰©å±•ä¸º URL å‚æ•°
const paginatedAnimeList = animeList.slice((currentPage - 1) * itemsPerPage, currentPage * itemsPerPage);

// --- æ—¶é—´ ---
const updateTime = new Date().toLocaleString("zh-CN", {
	year: "numeric",
	month: "long",
	day: "numeric",
	hour: "2-digit",
	minute: "2-digit",
});

// --- åŠ¨æ€åˆ†é¡µæŒ‰é’®ç”Ÿæˆå‡½æ•° ---
function renderPagination() {
	if (totalPages <= 1) return "";

	const maxVisible = 5;
	let start = Math.max(1, currentPage - Math.floor(maxVisible / 2));
	let end = Math.min(totalPages, start + maxVisible - 1);
	if (end - start < maxVisible - 1) start = Math.max(1, end - maxVisible + 1);

	const buttons = [];

	if (start > 1) {
		buttons.push(`<button class="page-btn px-3 py-1.5 rounded-md border border-[var(--line-divider)] text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">&lt;</button>`);
		if (start > 2) {
			buttons.push(`<button class="page-btn px-3 py-1.5 rounded-md border border-[var(--line-divider)] text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">1</button>`);
			if (start > 3) buttons.push(`<span class="px-3 py-1.5 text-gray-500 dark:text-gray-400">...</span>`);
		}
	}

	for (let i = start; i <= end; i++) {
		buttons.push(
			`<button class="page-btn px-3 py-1.5 rounded-md ${
				i === currentPage
					? 'bg-blue-500 text-white'
					: 'border border-[var(--line-divider)] text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700'
			} transition-colors">${i}</button>`
		);
	}

	if (end < totalPages) {
		if (end < totalPages - 1) {
			buttons.push(`<span class="px-3 py-1.5 text-gray-500 dark:text-gray-400">...</span>`);
		}
		buttons.push(`<button class="page-btn px-3 py-1.5 rounded-md border border-[var(--line-divider)] text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">${totalPages}</button>`);
		buttons.push(`<button class="page-btn px-3 py-1.5 rounded-md border border-[var(--line-divider)] text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">&gt;</button>`);
	}

	return buttons.join('');
}
---

<MainGridLayout title={i18n(I18nKey.anime)} description={i18n(I18nKey.animeSubtitle)}>
  <div class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32">
    <div class="card-base z-10 px-9 py-6 relative w-full">
      <!-- æ ‡é¢˜ -->
      <div class="relative w-full mb-8">
        <div class="mb-6">
          <h1 class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2 relative before:w-1 before:h-8 before:rounded-md before:bg-[var(--primary)] before:absolute before:top-1/2 before:-translate-y-1/2 before:-left-4">
            {i18n(I18nKey.animeTitle)}
          </h1>
          <p class="text-black/75 dark:text-white/75">{i18n(I18nKey.animeSubtitle)}</p>
        </div>

        <!-- ç»Ÿè®¡æ  -->
        <div class="stats-bar flex items-center justify-between mb-6 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm rounded-lg p-3 border border-[var(--line-divider)]">
          <div class="flex space-x-6">
            <div class="flex items-center">
              <span class="text-sm font-medium text-black/70 dark:text-white/70 mr-2">{i18n(I18nKey.anime)}</span>
              <span class="text-lg font-bold text-black/90 dark:text-white/90">{stats.total}</span>
            </div>
            <div class="flex items-center">
              <span class="text-sm font-medium text-black/70 dark:text-white/70 mr-2">{i18n(I18nKey.game)}</span>
              <span class="text-lg font-bold text-black/90 dark:text-white/90">{gameStats.total}</span>
            </div>
          </div>
          <div class="text-sm text-black/60 dark:text-white/60">
            {i18n(I18nKey.updatedAt)} {updateTime}
          </div>
        </div>

        <!-- è¿‡æ»¤æŒ‰é’® -->
        <div class="mb-6">
          <div class="filter-container flex flex-wrap gap-2">
            <button class="filter-tag active" data-status="all">{i18n(I18nKey.animeFilterAll)}</button>
            <button class="filter-tag" data-status="watching">{i18n(I18nKey.animeStatusWatching)}</button>
            <button class="filter-tag" data-status="planned">{i18n(I18nKey.animeStatusPlanned)}</button>
            <button class="filter-tag" data-status="completed">{i18n(I18nKey.animeStatusCompleted)}</button>
            {ANIME_MODE === 'bangumi' && (
              <>
                <button class="filter-tag" data-status="onhold">{i18n(I18nKey.animeStatusOnHold)}</button>
                <button class="filter-tag" data-status="dropped">{i18n(I18nKey.animeStatusDropped)}</button>
              </>
            )}
          </div>
        </div>
      </div>

      <!-- åŠ¨æ¼«åˆ—è¡¨ -->
      <div class="mb-8">
        {ANIME_MODE !== 'local' && BANGUMI_USER_ID === 'your-user-id' ? (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ˜¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">{i18n(I18nKey.animeEmpty)}</h3>
            <p class="text-black/60 dark:text-white/60">è¯·åœ¨ src/config.ts æ–‡ä»¶ä¸­è®¾ç½®ä½ çš„ Bangumi ç”¨æˆ·ID</p>
          </div>
        ) : paginatedAnimeList.length > 0 ? (
          <div id="anime-list-container" class={`anime-grid-container grid gap-4 md:gap-6 list-mode ${isBothSidebarMode ? "both-sidebar" : "single-sidebar"}`}>
            {paginatedAnimeList.map(anime => {
              const statusInfo = getStatusInfo(anime.status);
              const progressPercent = anime.totalEpisodes > 0 ? (anime.progress / anime.totalEpisodes) * 100 : 0;
              return (
                <div class="group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden transition-all duration-300 hover:shadow-lg hover:scale-[1.02]" data-anime-status={anime.status}>
                  {/* å°é¢ç­‰ç»“æ„ä¿æŒä¸å˜ */}
                  <div class="relative aspect-[2/3] overflow-hidden">
                    <a href={anime.link} target="_blank" rel="noopener noreferrer" class="block w-full h-full">
                      <ImageWrapper src={anime.cover} alt={anime.title} class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110" />
                      <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                        <div class="absolute inset-0 flex items-center justify-center">
                          <div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
                            <svg class="w-6 h-6 text-gray-800 ml-1" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                          </div>
                        </div>
                      </div>
                    </a>
                    <div class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}`}>
                      <span class="mr-1">{statusInfo.icon}</span><span>{statusInfo.text}</span>
                    </div>
                    <div class="absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded-md text-xs font-medium flex items-center gap-1">
                      <svg class="w-3 h-3 text-yellow-400" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/></svg>
                      <span>{anime.rating}</span>
                    </div>
                    {anime.status === 'watching' && (
                      <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-2">
                        <div class="w-full bg-white/20 rounded-full h-1.5 mb-1">
                          <div class="bg-gradient-to-r from-emerald-400 to-teal-400 h-1.5 rounded-full transition-all duration-300" style={`width: ${progressPercent}%`}></div>
                        </div>
                        <div class="text-white text-xs font-medium">{anime.progress}/{anime.totalEpisodes} ({Math.round(progressPercent)}%)</div>
                      </div>
                    )}
                  </div>
                  <div class="p-3">
                    <h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 line-clamp-2 leading-tight">{anime.title}</h3>
                    <p class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2">{anime.description}</p>
                    <div class="space-y-1 text-xs">
                      <div class="flex justify-between"><span class="text-black/50 dark:text-white/50">{i18n(I18nKey.animeYear)}</span><span class="text-black/70 dark:text-white/70">{anime.year}</span></div>
                      <div class="flex justify-between"><span class="text-black/50 dark:text-white/50">{i18n(I18nKey.animeStudio)}</span><span class="text-black/70 dark:text-white/70 truncate ml-2">{anime.studio}</span></div>
                      <div class="flex flex-wrap gap-1 mt-2">
                        {anime.genre.map(g => <span class="px-1.5 py-0.5 bg-[var(--btn-regular-bg)] text-black/70 dark:text-white/70 rounded text-xs">{g}</span>)}
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        ) : (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ˜¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">{i18n(I18nKey.animeEmpty)}</h3>
            <p class="text-black/60 dark:text-white/60">
              {ANIME_MODE === 'local' ? i18n(I18nKey.animeEmptyLocal) : i18n(I18nKey.animeEmptyBangumi)}
            </p>
          </div>
        )}
      </div>

      <!-- åŠ¨æ€åˆ†é¡µ -->
      {totalPages > 1 && (
        <div class="pagination flex justify-center items-center gap-2 mt-8 mb-6" set:html={renderPagination()} />
      )}

      <!-- æ¸¸æˆç›®å½• -->
      {gameList.length > 0 && (
        <div class="mt-12">
          <h2 class="text-2xl font-bold mb-4">{i18n(I18nKey.gameCatalog)}</h2>
          <p class="text-gray-600 dark:text-gray-400 mb-4">{i18n(I18nKey.gameCatalogDesc)}</p>
          <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            {gameList.map(game => (
              <div class="border border-[var(--line-divider)] rounded-lg p-4 bg-[var(--card-bg)]">
                <h3 class="font-semibold text-black/90 dark:text-white/90">{game.title}</h3>
                <p class="text-sm text-gray-600 dark:text-gray-400">{game.description}</p>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  </div>

  <!-- åŸæœ‰ JS è„šæœ¬ï¼ˆå¸ƒå±€ã€è¿‡æ»¤ï¼‰ä¿æŒä¸å˜ -->
  <script is:inline define:vars={{ isBothSidebarMode }}>
    // ...ï¼ˆä½ åŸæœ‰çš„ layoutManager è„šæœ¬ï¼‰
  </script>

  <style>
    /* ä½ çš„åŸæœ‰æ ·å¼ */
    .card-base { container-type: inline-size; }
    .anime-grid-container { display: grid; grid-template-columns: repeat(2, 1fr); transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
    .anime-grid-container.single-sidebar {
      @container (min-width: 900px) { grid-template-columns: repeat(5, 1fr); }
      @container (min-width: 600px) and (max-width: 899px) { grid-template-columns: repeat(3, 1fr); }
      @container (max-width: 599px) { grid-template-columns: repeat(2, 1fr); }
    }
    .anime-grid-container.both-sidebar {
      @container (min-width: 950px) { grid-template-columns: repeat(5, 1fr); }
      @container (min-width: 650px) and (max-width: 949px) { grid-template-columns: repeat(4, 1fr); }
      @container (min-width: 480px) and (max-width: 649px) { grid-template-columns: repeat(3, 1fr); }
      @container (max-width: 479px) { grid-template-columns: repeat(2, 1fr); }
    }
    /* å…¶ä»–æ ·å¼ç•¥ */
    .stats-bar {
      margin-bottom: 1rem;
      border-radius: var(--radius-large);
      padding: 0.75rem;
      border: 1px solid var(--line-divider);
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    @media (prefers-color-scheme: dark) {
      .stats-bar { background: rgba(17, 24, 39, 0.8); }
    }
    .pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
      margin-top: 1.5rem;
    }
    .page-btn {
      padding: 0.5rem 0.75rem;
      border: 1px solid var(--line-divider);
      border-radius: var(--radius-large);
      background: white;
      color: var(--text-primary);
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .page-btn:hover:not(.active) {
      background: var(--btn-hover-bg);
      border-color: var(--primary);
    }
    .page-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }
  </style>

  <!-- è¿‡æ»¤è„šæœ¬ï¼ˆä¿æŒä¸å˜ï¼‰ -->
  <script is:inline>
    // ...ï¼ˆä½ åŸæœ‰çš„ filter è„šæœ¬ï¼‰
  </script>
</MainGridLayout>
